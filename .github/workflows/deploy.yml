name: Deploy xRegistry to Azure Container Apps

on:
  push:
    branches: [ "main" ]
    tags: [ 'v*.*.*' ]
    paths:
      - 'bridge/**'
      - 'npm/**'
      - 'pypi/**'
      - 'maven/**'
      - 'nuget/**'
      - 'oci/**'
      - 'docker-compose.yml'
      - 'Dockerfile'
      - '.github/workflows/deploy.yml'
  workflow_run:
    workflows: ["Build NPM xRegistry", "Build PyPI xRegistry", "Build Maven xRegistry", "Build NuGet xRegistry", "Build OCI xRegistry", "Build Bridge xRegistry"]
    types: [completed]
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      deploy:
        description: 'Deploy to Azure Container Apps'
        required: false
        default: true
        type: boolean
      resource_group:
        description: 'Azure Resource Group'
        required: false
        default: 'xregistry-package-registries'
        type: string
      location:
        description: 'Azure Region'
        required: false
        default: 'westeurope'
        type: string
      env_name:
        description: 'Container App Environment Name'
        required: false
        default: 'xregistry-package-registries'
        type: string
      app_name:
        description: 'Container App Name (all services)'
        required: false
        default: 'xregistry-package-registries'
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_PREFIX: ${{ github.repository }}/xregistry

jobs:
  deploy:
    if: ${{ github.event.inputs.deploy == 'true' || github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
      id-token: write

    env:
      RESOURCE_GROUP: ${{ github.event.inputs.resource_group || 'xregistry-package-registries' }}
      LOCATION:       ${{ github.event.inputs.location       || 'westeurope' }}
      ENV_NAME:       ${{ github.event.inputs.env_name       || 'xregistry-package-registries' }}
      APP_NAME:       ${{ github.event.inputs.app_name       || 'xregistry-package-registries' }}

    steps:
      - uses: actions/checkout@v4

      - name: Check Azure Credentials
        run: |
          if [[ -z "${{ secrets.AZURE_CREDENTIALS }}" ]]; then
            echo "‚ùå AZURE_CREDENTIALS secret is not set!"
            echo ""
            echo "üîß To set up Azure deployment credentials, run:"
            echo "   # Windows (PowerShell)"
            echo "   .\setup-deployment-secrets.ps1 -RepoOwner ${{ github.repository_owner }}"
            echo ""
            echo "   # Linux/macOS (Bash)"  
            echo "   ./setup-deployment-secrets.sh -o ${{ github.repository_owner }}"
            echo ""
            echo "üìñ See ACTIONS.md for detailed setup instructions."
            exit 1
          fi
          echo "‚úÖ Azure credentials are configured"

      - uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Install Container Apps extension
        run: az extension add --name containerapp --yes

      - name: Determine image tag
        id: tag
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            echo "IMAGE_TAG=${{ github.ref_name }}" >> $GITHUB_ENV
          else
            echo "IMAGE_TAG=latest" >> $GITHUB_ENV
          fi

      - name: Ensure Resource Group
        run: |
          if ! az group show --name $RESOURCE_GROUP &>/dev/null; then
            echo "Creating resource group $RESOURCE_GROUP..."
            az group create --name $RESOURCE_GROUP --location $LOCATION
          fi

      - name: Ensure Container App Environment
        run: |
          if ! az containerapp env show --name $ENV_NAME --resource-group $RESOURCE_GROUP &>/dev/null; then
            echo "Creating Container App environment $ENV_NAME..."
            az containerapp env create \
              --name $ENV_NAME \
              --resource-group $RESOURCE_GROUP \
              --location $LOCATION \
              --logs-destination none
          fi

      - name: Get Environment ID
        id: get-env-id
        run: |
          SUBSCRIPTION_ID=$(az account show --query id --output tsv)
          echo "subscription-id=$SUBSCRIPTION_ID" >> $GITHUB_OUTPUT
          echo "Subscription ID: $SUBSCRIPTION_ID"

      - name: Generate API Keys
        id: api-keys
        run: |
          # Generate unique API keys for each service
          NPM_API_KEY="npm-$(openssl rand -hex 16)"
          PYPI_API_KEY="pypi-$(openssl rand -hex 16)"
          MAVEN_API_KEY="maven-$(openssl rand -hex 16)"
          NUGET_API_KEY="nuget-$(openssl rand -hex 16)"
          OCI_API_KEY="oci-$(openssl rand -hex 16)"
          
          echo "NPM_API_KEY=$NPM_API_KEY" >> $GITHUB_ENV
          echo "PYPI_API_KEY=$PYPI_API_KEY" >> $GITHUB_ENV
          echo "MAVEN_API_KEY=$MAVEN_API_KEY" >> $GITHUB_ENV
          echo "NUGET_API_KEY=$NUGET_API_KEY" >> $GITHUB_ENV
          echo "OCI_API_KEY=$OCI_API_KEY" >> $GITHUB_ENV
          
          echo "‚úÖ Generated unique API keys for all services"

      - name: Deploy xRegistry Container App (All Services)
        run: |
          # Image URIs
          BRIDGE_IMG="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-bridge:${{ env.IMAGE_TAG }}"
          NPM_IMG="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-npm-bridge:${{ env.IMAGE_TAG }}"
          PYPI_IMG="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-pypi-bridge:${{ env.IMAGE_TAG }}"
          MAVEN_IMG="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-maven-bridge:${{ env.IMAGE_TAG }}"
          NUGET_IMG="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-nuget-bridge:${{ env.IMAGE_TAG }}"
          OCI_IMG="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-oci-bridge:${{ env.IMAGE_TAG }}"
          
          # Create downstreams configuration for bridge
          DOWNSTREAMS_JSON=$(cat << 'EOF'
          {
            "servers": [
              {
                "url": "http://localhost:3100",
                "apikey": "$NPM_API_KEY"
              },
              {
                "url": "http://localhost:3000",
                "apikey": "$PYPI_API_KEY"
              },
              {
                "url": "http://localhost:3300",
                "apikey": "$MAVEN_API_KEY"
              },
              {
                "url": "http://localhost:3200",
                "apikey": "$NUGET_API_KEY"
              },
              {
                "url": "http://localhost:3400",
                "apikey": "$OCI_API_KEY"
              }
            ]
          }
          EOF
          )
          
          # Substitute environment variables in downstreams JSON
          DOWNSTREAMS_JSON=$(echo "$DOWNSTREAMS_JSON" | envsubst)
          
          # Create Container App YAML configuration
          cat > containerapp.yaml << EOF
          properties:
            environmentId: /subscriptions/${{ steps.get-env-id.outputs.subscription-id }}/resourceGroups/$RESOURCE_GROUP/providers/Microsoft.App/managedEnvironments/$ENV_NAME
            configuration:
              ingress:
                external: true
                targetPort: 8092
                allowInsecure: false
              registries:
                - server: ${{ env.REGISTRY }}
                  username: ${{ github.actor }}
                  passwordSecretRef: registry-password
              secrets:
                - name: registry-password
                  value: ${{ secrets.GITHUB_TOKEN }}
                - name: npm-api-key
                  value: $NPM_API_KEY
                - name: pypi-api-key
                  value: $PYPI_API_KEY
                - name: maven-api-key
                  value: $MAVEN_API_KEY
                - name: nuget-api-key
                  value: $NUGET_API_KEY
                - name: oci-api-key
                  value: $OCI_API_KEY
            template:
              containers:
                - name: bridge
                  image: $BRIDGE_IMG
                  resources:
                    cpu: 0.5
                    memory: 1Gi
                  ports:
                    - containerPort: 8092
                      protocol: TCP
                  env:
                    - name: NODE_ENV
                      value: production
                    - name: PORT
                      value: "8092"
                    - name: XREGISTRY_BRIDGE_PORT
                      value: "8092"
                    - name: XREGISTRY_BRIDGE_BASEURL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: BASE_URL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: XREGISTRY_BRIDGE_QUIET
                      value: "false"
                    - name: DOWNSTREAMS_JSON
                      value: '$DOWNSTREAMS_JSON'
                - name: npm
                  image: $NPM_IMG
                  resources:
                    cpu: 0.75
                    memory: 1.5Gi
                  ports:
                    - containerPort: 3100
                      protocol: TCP
                  env:
                    - name: NODE_ENV
                      value: production
                    - name: PORT
                      value: "3100"
                    - name: XREGISTRY_NPM_PORT
                      value: "3100"
                    - name: XREGISTRY_NPM_BASEURL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: BASE_URL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: XREGISTRY_NPM_QUIET
                      value: "false"
                    - name: XREGISTRY_NPM_API_KEY
                      secretRef: npm-api-key
                - name: pypi
                  image: $PYPI_IMG
                  resources:
                    cpu: 0.75
                    memory: 1.5Gi
                  ports:
                    - containerPort: 3000
                      protocol: TCP
                  env:
                    - name: NODE_ENV
                      value: production
                    - name: PORT
                      value: "3000"
                    - name: XREGISTRY_PYPI_PORT
                      value: "3000"
                    - name: XREGISTRY_PYPI_BASEURL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: BASE_URL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: XREGISTRY_PYPI_QUIET
                      value: "false"
                    - name: XREGISTRY_PYPI_API_KEY
                      secretRef: pypi-api-key
                - name: maven
                  image: $MAVEN_IMG
                  resources:
                    cpu: 0.75
                    memory: 1.5Gi
                  ports:
                    - containerPort: 3300
                      protocol: TCP
                  env:
                    - name: NODE_ENV
                      value: production
                    - name: PORT
                      value: "3300"
                    - name: XREGISTRY_MAVEN_PORT
                      value: "3300"
                    - name: XREGISTRY_MAVEN_BASEURL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: BASE_URL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: XREGISTRY_MAVEN_QUIET
                      value: "false"
                    - name: XREGISTRY_MAVEN_API_KEY
                      secretRef: maven-api-key
                - name: nuget
                  image: $NUGET_IMG
                  resources:
                    cpu: 0.75
                    memory: 1.5Gi
                  ports:
                    - containerPort: 3200
                      protocol: TCP
                  env:
                    - name: NODE_ENV
                      value: production
                    - name: PORT
                      value: "3200"
                    - name: XREGISTRY_NUGET_PORT
                      value: "3200"
                    - name: XREGISTRY_NUGET_BASEURL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: BASE_URL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: XREGISTRY_NUGET_QUIET
                      value: "false"
                    - name: XREGISTRY_NUGET_API_KEY
                      secretRef: nuget-api-key
                - name: oci
                  image: $OCI_IMG
                  resources:
                    cpu: 0.5
                    memory: 1Gi
                  ports:
                    - containerPort: 3400
                      protocol: TCP
                  env:
                    - name: NODE_ENV
                      value: production
                    - name: PORT
                      value: "3400"
                    - name: XREGISTRY_OCI_PORT
                      value: "3400"
                    - name: XREGISTRY_OCI_BASEURL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: BASE_URL
                      value: "https://\$APP_FQDN_PLACEHOLDER"
                    - name: XREGISTRY_OCI_QUIET
                      value: "false"
                    - name: XREGISTRY_OCI_API_KEY
                      secretRef: oci-api-key
              scale:
                minReplicas: 1
                maxReplicas: 3
          EOF
          
          # Function to wait for any ongoing operations to complete
          wait_for_containerapp_ready() {
            local max_attempts=30
            local attempt=1
            
            echo "Checking for ongoing operations..."
            while [ $attempt -le $max_attempts ]; do
              # Get the provisioning state
              PROVISIONING_STATE=$(az containerapp show --name $APP_NAME --resource-group $RESOURCE_GROUP --query 'properties.provisioningState' -o tsv 2>/dev/null || echo "NotFound")
              
              if [ "$PROVISIONING_STATE" = "Succeeded" ] || [ "$PROVISIONING_STATE" = "NotFound" ]; then
                echo "‚úÖ Container App is ready for operations (State: $PROVISIONING_STATE)"
                return 0
              elif [ "$PROVISIONING_STATE" = "InProgress" ] || [ "$PROVISIONING_STATE" = "Running" ]; then
                echo "‚è≥ Container App operation in progress (State: $PROVISIONING_STATE). Waiting... (attempt $attempt/$max_attempts)"
                sleep 30
              else
                echo "‚ö†Ô∏è  Unexpected provisioning state: $PROVISIONING_STATE (attempt $attempt/$max_attempts)"
                sleep 15
              fi
              
              ((attempt++))
            done
            
            echo "‚ùå Timeout waiting for Container App to be ready after $max_attempts attempts"
            return 1
          }
          
          # Function to deploy/update with retry logic
          deploy_containerapp() {
            local max_retries=5
            local retry=1
            local base_delay=30
            
            while [ $retry -le $max_retries ]; do
              echo "Deployment attempt $retry/$max_retries..."
              
              # Check if container app exists
              if az containerapp show --name $APP_NAME --resource-group $RESOURCE_GROUP &>/dev/null; then
                echo "Updating Container App with all services..."
                if az containerapp update \
                  --name $APP_NAME \
                  --resource-group $RESOURCE_GROUP \
                  --yaml containerapp.yaml; then
                  echo "‚úÖ Container App updated successfully"
                  return 0
                fi
              else
                echo "Creating Container App with all services..."
                if az containerapp create \
                  --name $APP_NAME \
                  --resource-group $RESOURCE_GROUP \
                  --yaml containerapp.yaml; then
                  echo "‚úÖ Container App created successfully"
                  return 0
                fi
              fi
              
              # If we get here, the operation failed
              local exit_code=$?
              echo "‚ùå Deployment attempt $retry failed with exit code $exit_code"
              
              if [ $retry -eq $max_retries ]; then
                echo "‚ùå All deployment attempts failed"
                return $exit_code
              fi
              
              # Wait before retry with exponential backoff
              local delay=$((base_delay * retry))
              echo "‚è≥ Waiting ${delay}s before retry..."
              sleep $delay
              
              # Wait for any ongoing operations to complete before retrying
              wait_for_containerapp_ready
              
              ((retry++))
            done
          }
          
          # Wait for any ongoing operations to complete first
          wait_for_containerapp_ready
          
          # Deploy or update the container app using YAML with retry logic
          deploy_containerapp
          
          # Get the actual FQDN and update the containerapp.yaml with real URLs
          APP_FQDN=$(az containerapp show --name $APP_NAME --resource-group $RESOURCE_GROUP --query 'properties.configuration.ingress.fqdn' -o tsv)
          echo "Updating BASE_URLs with actual FQDN: $APP_FQDN"
          
          # Replace placeholders with actual FQDN
          sed -i "s|\\\$APP_FQDN_PLACEHOLDER|$APP_FQDN|g" containerapp.yaml
          
          # Deploy again with correct URLs
          echo "Updating Container App with correct BASE_URLs..."
          wait_for_containerapp_ready
          deploy_containerapp

      - name: Update Bridge with Correct Base URL
        run: |
          # Function to wait for any ongoing operations to complete
          wait_for_containerapp_ready() {
            local max_attempts=30
            local attempt=1
            
            echo "Checking for ongoing operations..."
            while [ $attempt -le $max_attempts ]; do
              # Get the provisioning state
              PROVISIONING_STATE=$(az containerapp show --name $APP_NAME --resource-group $RESOURCE_GROUP --query 'properties.provisioningState' -o tsv 2>/dev/null || echo "NotFound")
              
              if [ "$PROVISIONING_STATE" = "Succeeded" ] || [ "$PROVISIONING_STATE" = "NotFound" ]; then
                echo "‚úÖ Container App is ready for operations (State: $PROVISIONING_STATE)"
                return 0
              elif [ "$PROVISIONING_STATE" = "InProgress" ] || [ "$PROVISIONING_STATE" = "Running" ]; then
                echo "‚è≥ Container App operation in progress (State: $PROVISIONING_STATE). Waiting... (attempt $attempt/$max_attempts)"
                sleep 30
              else
                echo "‚ö†Ô∏è  Unexpected provisioning state: $PROVISIONING_STATE (attempt $attempt/$max_attempts)"
                sleep 15
              fi
              
              ((attempt++))
            done
            
            echo "‚ùå Timeout waiting for Container App to be ready after $max_attempts attempts"
            return 1
          }
          
          # Get the actual FQDN now that the app is created
          APP_FQDN=$(az containerapp show --name $APP_NAME --resource-group $RESOURCE_GROUP --query 'properties.configuration.ingress.fqdn' -o tsv)
          
          # Create updated downstreams configuration
          DOWNSTREAMS_JSON=$(cat << 'EOF'
          {
            "servers": [
              {
                "url": "http://localhost:3100",
                "apikey": "$NPM_API_KEY"
              },
              {
                "url": "http://localhost:3000",
                "apikey": "$PYPI_API_KEY"
              },
              {
                "url": "http://localhost:3300",
                "apikey": "$MAVEN_API_KEY"
              },
              {
                "url": "http://localhost:3200",
                "apikey": "$NUGET_API_KEY"
              },
              {
                "url": "http://localhost:3400",
                "apikey": "$OCI_API_KEY"
              }
            ]
          }
          EOF
          )
          
          # Substitute environment variables in downstreams JSON
          DOWNSTREAMS_JSON=$(echo "$DOWNSTREAMS_JSON" | envsubst)
          
          # Create updated YAML with correct base URL
          BRIDGE_IMG="${{ env.REGISTRY }}/${{ env.IMAGE_PREFIX }}-bridge:${{ env.IMAGE_TAG }}"
          
          cat > containerapp-update.yaml << EOF
          properties:
            template:
              containers:
                - name: bridge
                  image: $BRIDGE_IMG
                  resources:
                    cpu: 0.5
                    memory: 1Gi
                  env:
                    - name: NODE_ENV
                      value: production
                    - name: PORT
                      value: "8092"
                    - name: XREGISTRY_BRIDGE_PORT
                      value: "8092"
                    - name: XREGISTRY_BRIDGE_BASEURL
                      value: "https://$APP_FQDN"
                    - name: XREGISTRY_BRIDGE_QUIET
                      value: "false"
                    - name: DOWNSTREAMS_JSON
                      value: '$DOWNSTREAMS_JSON'
          EOF
          
          # Update only the bridge container environment with retry logic
          echo "Updating bridge with correct base URL..."
          for retry in {1..3}; do
            echo "Bridge update attempt $retry/3..."
            
            # Wait for container app to be ready
            wait_for_containerapp_ready
            
            if az containerapp update \
              --name $APP_NAME \
              --resource-group $RESOURCE_GROUP \
              --yaml containerapp-update.yaml; then
              echo "‚úÖ Bridge updated successfully with correct base URL"
              break
            else
              echo "‚ùå Bridge update attempt $retry failed"
              if [ $retry -eq 3 ]; then
                echo "‚ùå All bridge update attempts failed"
                exit 1
              fi
              echo "‚è≥ Waiting 60s before retry..."
              sleep 60
            fi
          done

      - name: Health Checks and URLs
        run: |
          echo "üéâ Deployment completed successfully!"
          echo ""
          echo "üìç Service Endpoints:"
          APP_FQDN=$(az containerapp show --name $APP_NAME --resource-group $RESOURCE_GROUP --query 'properties.configuration.ingress.fqdn' -o tsv)
          echo "üîó xRegistry (Unified): https://$APP_FQDN"
          echo ""
          echo "üìä Container App Architecture:"
          echo "  ‚Ä¢ Bridge (External):   Port 8092 ‚Üí https://$APP_FQDN"
          echo "  ‚Ä¢ NPM Registry:        Port 3100 ‚Üí http://localhost:3100 (internal)"
          echo "  ‚Ä¢ PyPI Registry:       Port 3000 ‚Üí http://localhost:3000 (internal)"
          echo "  ‚Ä¢ Maven Registry:      Port 3300 ‚Üí http://localhost:3300 (internal)"
          echo "  ‚Ä¢ NuGet Registry:      Port 3200 ‚Üí http://localhost:3200 (internal)"
          echo "  ‚Ä¢ OCI Registry:        Port 3000 ‚Üí http://localhost:3000 (internal)"
          echo ""
          echo "üè• Test the unified endpoint:"
          echo "curl https://$APP_FQDN/"
          echo "curl https://$APP_FQDN/model"
          echo "curl https://$APP_FQDN/capabilities"

      - name: Wait for Services and Test
        run: |
          # Function to wait for any ongoing operations to complete
          wait_for_containerapp_ready() {
            local max_attempts=30
            local attempt=1
            
            echo "Checking for ongoing operations..."
            while [ $attempt -le $max_attempts ]; do
              # Get the provisioning state
              PROVISIONING_STATE=$(az containerapp show --name $APP_NAME --resource-group $RESOURCE_GROUP --query 'properties.provisioningState' -o tsv 2>/dev/null || echo "NotFound")
              
              if [ "$PROVISIONING_STATE" = "Succeeded" ] || [ "$PROVISIONING_STATE" = "NotFound" ]; then
                echo "‚úÖ Container App is ready for operations (State: $PROVISIONING_STATE)"
                return 0
              elif [ "$PROVISIONING_STATE" = "InProgress" ] || [ "$PROVISIONING_STATE" = "Running" ]; then
                echo "‚è≥ Container App operation in progress (State: $PROVISIONING_STATE). Waiting... (attempt $attempt/$max_attempts)"
                sleep 30
              else
                echo "‚ö†Ô∏è  Unexpected provisioning state: $PROVISIONING_STATE (attempt $attempt/$max_attempts)"
                sleep 15
              fi
              
              ((attempt++))
            done
            
            echo "‚ùå Timeout waiting for Container App to be ready after $max_attempts attempts"
            return 1
          }
          
          # Wait for container app to be fully ready before testing
          wait_for_containerapp_ready
          
          APP_FQDN=$(az containerapp show --name $APP_NAME --resource-group $RESOURCE_GROUP --query 'properties.configuration.ingress.fqdn' -o tsv)
          BRIDGE_URL="https://$APP_FQDN"
          
          echo "Waiting for bridge service to be ready..."
          for i in {1..30}; do
            if curl -f -s "$BRIDGE_URL/" > /dev/null 2>&1; then
              echo "‚úÖ Bridge service is responding!"
              break
            else
              echo "‚è≥ Waiting for bridge... (attempt $i/30)"
              sleep 10
            fi
          done
          
          echo "Testing unified API endpoints..."
          curl -f "$BRIDGE_URL/" || echo "‚ùå Root endpoint failed"
          curl -f "$BRIDGE_URL/model" || echo "‚ùå Model endpoint failed"
          curl -f "$BRIDGE_URL/capabilities" || echo "‚ùå Capabilities endpoint failed" 